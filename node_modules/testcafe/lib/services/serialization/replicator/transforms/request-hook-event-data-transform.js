"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const EVENT_CONSTRUCTORS = [
    testcafe_hammerhead_1.RequestEvent,
    testcafe_hammerhead_1.ConfigureResponseEvent,
    testcafe_hammerhead_1.ResponseEvent
];
const EVENT_CONSTRUCTORS_MAP = new Map(EVENT_CONSTRUCTORS.map(eventConstructor => {
    return [eventConstructor.name, eventConstructor];
}));
class RequestHookEventDataTransform {
    constructor() {
        this.type = 'RequestHookEventData';
    }
    shouldTransform(_, val) {
        return EVENT_CONSTRUCTORS.some(EventConstructor => val instanceof EventConstructor);
    }
    toSerializable(value) {
        // TODO: Remove eventData._requestContext into 'testcafe-hammerhead' module
        // after switching to the compiler service mode.
        // NOTE: Access to the deprecated property inside of the unserializable 'eventData._requestContext' property
        // causes the node's deprecation warning.
        const clonedEventData = Object.assign({}, value);
        // @ts-ignore
        delete clonedEventData._requestContext;
        return {
            constructorName: value.constructor.name,
            data: clonedEventData
        };
    }
    fromSerializable(value) {
        const EventConstructor = EVENT_CONSTRUCTORS_MAP.get(value.constructorName);
        if (!EventConstructor)
            throw new Error(`An appropriate command constructor for "${value.constructorName}" type was not found.`);
        return EventConstructor.from(value.data);
    }
}
exports.default = RequestHookEventDataTransform;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdC1ob29rLWV2ZW50LWRhdGEtdHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3NlcnZpY2VzL3NlcmlhbGl6YXRpb24vcmVwbGljYXRvci90cmFuc2Zvcm1zL3JlcXVlc3QtaG9vay1ldmVudC1kYXRhLXRyYW5zZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZEQUk2QjtBQUc3QixNQUFNLGtCQUFrQixHQUFHO0lBQ3ZCLGtDQUFZO0lBQ1osNENBQXNCO0lBQ3RCLG1DQUFhO0NBQ2hCLENBQUM7QUFJRixNQUFNLHNCQUFzQixHQUFHLElBQUksR0FBRyxDQUEyQixrQkFBa0IsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtJQUN2RyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUM7QUFDckQsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQU9KLE1BQXFCLDZCQUE2QjtJQUc5QztRQUNJLElBQUksQ0FBQyxJQUFJLEdBQUcsc0JBQXNCLENBQUM7SUFDdkMsQ0FBQztJQUVNLGVBQWUsQ0FBRSxDQUFVLEVBQUUsR0FBWTtRQUM1QyxPQUFPLGtCQUFrQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLGdCQUFnQixDQUFDLENBQUM7SUFDeEYsQ0FBQztJQUVNLGNBQWMsQ0FBRSxLQUE0RDtRQUMvRSwyRUFBMkU7UUFDM0UsZ0RBQWdEO1FBRWhELDRHQUE0RztRQUM1Ryx5Q0FBeUM7UUFDekMsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFakQsYUFBYTtRQUNiLE9BQU8sZUFBZSxDQUFDLGVBQWUsQ0FBQztRQUV2QyxPQUFPO1lBQ0gsZUFBZSxFQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSTtZQUN2QyxJQUFJLEVBQWEsZUFBZTtTQUNuQyxDQUFDO0lBQ04sQ0FBQztJQUVNLGdCQUFnQixDQUFFLEtBQWlDO1FBQ3RELE1BQU0sZ0JBQWdCLEdBQUcsc0JBQXNCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUUzRSxJQUFJLENBQUMsZ0JBQWdCO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLEtBQUssQ0FBQyxlQUFlLHVCQUF1QixDQUFDLENBQUM7UUFFN0csT0FBTyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdDLENBQUM7Q0FDSjtBQXBDRCxnREFvQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbmZpZ3VyZVJlc3BvbnNlRXZlbnQsXG4gICAgUmVxdWVzdEV2ZW50LFxuICAgIFJlc3BvbnNlRXZlbnRcbn0gZnJvbSAndGVzdGNhZmUtaGFtbWVyaGVhZCc7XG5cblxuY29uc3QgRVZFTlRfQ09OU1RSVUNUT1JTID0gW1xuICAgIFJlcXVlc3RFdmVudCxcbiAgICBDb25maWd1cmVSZXNwb25zZUV2ZW50LFxuICAgIFJlc3BvbnNlRXZlbnRcbl07XG5cbnR5cGUgRXZlbnRDb25zdHJ1Y3RvciA9IHR5cGVvZiBSZXF1ZXN0RXZlbnQgfCB0eXBlb2YgQ29uZmlndXJlUmVzcG9uc2VFdmVudCB8IHR5cGVvZiBSZXNwb25zZUV2ZW50O1xuXG5jb25zdCBFVkVOVF9DT05TVFJVQ1RPUlNfTUFQID0gbmV3IE1hcDxzdHJpbmcsIEV2ZW50Q29uc3RydWN0b3I+KEVWRU5UX0NPTlNUUlVDVE9SUy5tYXAoZXZlbnRDb25zdHJ1Y3RvciA9PiB7XG4gICAgcmV0dXJuIFtldmVudENvbnN0cnVjdG9yLm5hbWUsIGV2ZW50Q29uc3RydWN0b3JdO1xufSkpO1xuXG5pbnRlcmZhY2UgU2VyaWFsaXplZFJlcXVlc3RIb29rRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yTmFtZTogc3RyaW5nO1xuICAgIGRhdGE6IHVua25vd247XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcXVlc3RIb29rRXZlbnREYXRhVHJhbnNmb3JtIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogc3RyaW5nO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ1JlcXVlc3RIb29rRXZlbnREYXRhJztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2hvdWxkVHJhbnNmb3JtIChfOiB1bmtub3duLCB2YWw6IHVua25vd24pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEVWRU5UX0NPTlNUUlVDVE9SUy5zb21lKEV2ZW50Q29uc3RydWN0b3IgPT4gdmFsIGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgcHVibGljIHRvU2VyaWFsaXphYmxlICh2YWx1ZTogUmVxdWVzdEV2ZW50IHwgQ29uZmlndXJlUmVzcG9uc2VFdmVudCB8IFJlc3BvbnNlRXZlbnQpOiBTZXJpYWxpemVkUmVxdWVzdEhvb2tFdmVudCB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBldmVudERhdGEuX3JlcXVlc3RDb250ZXh0IGludG8gJ3Rlc3RjYWZlLWhhbW1lcmhlYWQnIG1vZHVsZVxuICAgICAgICAvLyBhZnRlciBzd2l0Y2hpbmcgdG8gdGhlIGNvbXBpbGVyIHNlcnZpY2UgbW9kZS5cblxuICAgICAgICAvLyBOT1RFOiBBY2Nlc3MgdG8gdGhlIGRlcHJlY2F0ZWQgcHJvcGVydHkgaW5zaWRlIG9mIHRoZSB1bnNlcmlhbGl6YWJsZSAnZXZlbnREYXRhLl9yZXF1ZXN0Q29udGV4dCcgcHJvcGVydHlcbiAgICAgICAgLy8gY2F1c2VzIHRoZSBub2RlJ3MgZGVwcmVjYXRpb24gd2FybmluZy5cbiAgICAgICAgY29uc3QgY2xvbmVkRXZlbnREYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpO1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGVsZXRlIGNsb25lZEV2ZW50RGF0YS5fcmVxdWVzdENvbnRleHQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yTmFtZTogdmFsdWUuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgIGRhdGE6ICAgICAgICAgICAgY2xvbmVkRXZlbnREYXRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIGZyb21TZXJpYWxpemFibGUgKHZhbHVlOiBTZXJpYWxpemVkUmVxdWVzdEhvb2tFdmVudCk6IHVua25vd24ge1xuICAgICAgICBjb25zdCBFdmVudENvbnN0cnVjdG9yID0gRVZFTlRfQ09OU1RSVUNUT1JTX01BUC5nZXQodmFsdWUuY29uc3RydWN0b3JOYW1lKTtcblxuICAgICAgICBpZiAoIUV2ZW50Q29uc3RydWN0b3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGFwcHJvcHJpYXRlIGNvbW1hbmQgY29uc3RydWN0b3IgZm9yIFwiJHt2YWx1ZS5jb25zdHJ1Y3Rvck5hbWV9XCIgdHlwZSB3YXMgbm90IGZvdW5kLmApO1xuXG4gICAgICAgIHJldHVybiBFdmVudENvbnN0cnVjdG9yLmZyb20odmFsdWUuZGF0YSk7XG4gICAgfVxufVxuIl19